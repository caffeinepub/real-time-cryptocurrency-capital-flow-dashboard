/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @caffeinelabs/bindgen@0.1.0.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { Actor, HttpAgent, type HttpAgentOptions, type ActorConfig, type Agent, type ActorSubclass } from "@icp-sdk/core/agent";
import type { Principal } from "@icp-sdk/core/principal";
import { idlFactory, type _SERVICE } from "./declarations/backend.did";
export interface Some<T> {
    __kind__: "Some";
    value: T;
}
export interface None {
    __kind__: "None";
}
export type Option<T> = Some<T> | None;
function some<T>(value: T): Some<T> {
    return {
        __kind__: "Some",
        value: value
    };
}
function none(): None {
    return {
        __kind__: "None"
    };
}
function isNone<T>(option: Option<T>): option is None {
    return option.__kind__ === "None";
}
function isSome<T>(option: Option<T>): option is Some<T> {
    return option.__kind__ === "Some";
}
function unwrap<T>(option: Option<T>): T {
    if (isNone(option)) {
        throw new Error("unwrap: none");
    }
    return option.value;
}
function candid_some<T>(value: T): [T] {
    return [
        value
    ];
}
function candid_none<T>(): [] {
    return [];
}
function record_opt_to_undefined<T>(arg: T | null): T | undefined {
    return arg == null ? undefined : arg;
}
export class ExternalBlob {
    _blob?: Uint8Array<ArrayBuffer> | null;
    directURL: string;
    onProgress?: (percentage: number) => void = undefined;
    private constructor(directURL: string, blob: Uint8Array<ArrayBuffer> | null){
        if (blob) {
            this._blob = blob;
        }
        this.directURL = directURL;
    }
    static fromURL(url: string): ExternalBlob {
        return new ExternalBlob(url, null);
    }
    static fromBytes(blob: Uint8Array<ArrayBuffer>): ExternalBlob {
        const url = URL.createObjectURL(new Blob([
            new Uint8Array(blob)
        ], {
            type: 'application/octet-stream'
        }));
        return new ExternalBlob(url, blob);
    }
    public async getBytes(): Promise<Uint8Array<ArrayBuffer>> {
        if (this._blob) {
            return this._blob;
        }
        const response = await fetch(this.directURL);
        const blob = await response.blob();
        this._blob = new Uint8Array(await blob.arrayBuffer());
        return this._blob;
    }
    public getDirectURL(): string {
        return this.directURL;
    }
    public withUploadProgress(onProgress: (percentage: number) => void): ExternalBlob {
        this.onProgress = onProgress;
        return this;
    }
}
export interface RegionalFlow {
    velocity: number;
    toRegion: bigint;
    fromRegion: bigint;
    volume: number;
    timestamp: Time;
    correlations: Array<[string, number]>;
    intensity: number;
}
export interface TransformationOutput {
    status: bigint;
    body: Uint8Array;
    headers: Array<http_header>;
}
export type Time = bigint;
export interface InstitutionalAlert {
    intensityChange: number;
    type: string;
    alertId: bigint;
    volumeChange: number;
    timestamp: Time;
    regionId: bigint;
}
export interface ConfidenceMetrics {
    improvementRatio: number;
    averageConfidence: number;
    assetSymbol: string;
    accuracyImprovement: number;
    confidenceAccuracyCorrelation: number;
}
export interface RegionalMetric {
    value: number;
    timestamp: Time;
    metricType: string;
    regionId: bigint;
    symbol: string;
}
export interface PerformanceSummary {
    averageAccuracy: number;
    totalPredictions: bigint;
    validatedPredictions: bigint;
    assetSymbol: string;
    averageDeviation: number;
    lowestPerformer: string;
    highestPerformer: string;
    validationTime: number;
}
export interface AlertConfig {
    updated_at: Time;
    criticalAlertDays: Array<bigint>;
    minVolumeThreshold: number;
    highPriorityAlertTypes: Array<string>;
    maxAlertFrequency: bigint;
    minIntensityThreshold: number;
}
export interface TransformationInput {
    context: Uint8Array;
    response: http_request_result;
}
export interface PredictiveProjection {
    trend: string;
    asset: CryptoAsset;
    targetLevels: Array<TargetLevel>;
    confidenceLevel: number;
    precision: number;
    timeHorizon: bigint;
}
export interface RecoveryAsset {
    rsi: number;
    supports: Array<number>;
    patternType: string;
    volume: number;
    openInterest: number;
    isMomentumBreakout: boolean;
    isInstitutionalEntry: boolean;
    recoveryStrength: number;
    symbol: string;
}
export interface TargetLevel {
    priceLevel: number;
    source: string;
    confidenceScore: number;
    levelType: string;
    timestamp: Time;
}
export interface PriceTicker {
    price: number;
    symbol: string;
}
export interface PredictionOutcome {
    predictedValue: number;
    actualValue: number;
    confidence: number;
    outcome: string;
}
export interface RegionalFlowConfig {
    name: string;
    velocityMultiplier: number;
    countryCodes: Array<string>;
    intensityMultiplier: number;
    regionId: bigint;
    coordinates: [number, number];
}
export interface DayFlowRange {
    startTime: Time;
    endTime: Time;
    flowData: Array<RegionalFlow>;
}
export interface CryptoAsset {
    name: string;
    usdValue: number;
    symbol: string;
}
export interface http_header {
    value: string;
    name: string;
}
export interface http_request_result {
    status: bigint;
    body: Uint8Array;
    headers: Array<http_header>;
}
export interface Region {
    flowRatio: number;
    name: string;
    volume: number;
    capitalFlow: number;
    countryCodes: Array<string>;
    timestamp: Time;
    regionId: bigint;
    intensity: number;
    coordinates: [number, number];
}
export interface ModelPerformance {
    performanceScore: number;
    confidenceCorrelation: number;
    validationResults: Array<string>;
    deviation: number;
    predictions: Array<PredictionOutcome>;
    assetSymbol: string;
    modelName: string;
    timestamp: Time;
    validationTime: number;
    accuracy: number;
}
export interface ConfluenceZone {
    indicators: Array<string>;
    timestamp: Time;
    intensity: number;
}
export interface RegionalCryptoAsset {
    marketCap: number;
    name: string;
    liquidity: number;
    regionalVolume: number;
    usdValue: number;
    timestamp: Time;
    regionId: bigint;
    symbol: string;
}
export interface RegionalCorrelation {
    correlationStrength: number;
    timestamp: Time;
    regionId: bigint;
    symbol: string;
}
export interface AssetOutcomes {
    assetSymbol: string;
    predictionOutcomes: Array<PredictionOutcome>;
}
export interface CapitalFlow {
    marketImpact: number;
    flowIntensity: number;
    pnlRatio: number;
    timestamp: Time;
    amount: number;
    fromAsset: CryptoAsset;
    toAsset: CryptoAsset;
}
export interface NormalizedFuturesPosition {
    pnl: number;
    markPrice: number;
    leverage: number;
    positionSide: string;
    liquidationPrice: number;
    entryPrice: number;
    market: BinanceFuturesMarket;
    symbol: string;
    positionAmt: number;
}
export interface UserProfile {
    name: string;
    email?: string;
    preferences?: string;
}
export enum BinanceFuturesMarket {
    usdt_m = "usdt_m",
    coin_m = "coin_m"
}
export enum UserRole {
    admin = "admin",
    user = "user",
    guest = "guest"
}
export interface backendInterface {
    _initializeAccessControlWithSecret(userSecret: string): Promise<void>;
    addCapitalFlow(symbol: string, from: CryptoAsset, to: CryptoAsset, amount: number, intensity: number, pnlRatio: number, marketImpact: number): Promise<void>;
    addConfluenceZone(symbol: string, indicators: Array<string>, intensity: number): Promise<void>;
    addInstitutionalAlert(alertId: bigint, regionId: bigint, type: string, volumeChange: number, intensityChange: number): Promise<void>;
    addModelPerformance(symbol: string, modelName: string, accuracy: number, deviation: number, validationTime: number, performanceScore: number, confidence: number): Promise<void>;
    addOrUpdateBinanceCredentials(apiKey: string, apiSecret: string): Promise<void>;
    addPredictionOutcome(symbol: string, predictedValue: number, actualValue: number, confidence: number, outcome: string): Promise<void>;
    addPredictiveProjection(symbol: string, asset: CryptoAsset, trend: string, confidence: number, precision: number, horizon: bigint, targetLevels: Array<TargetLevel> | null): Promise<void>;
    addRecoveryAsset(symbol: string, recoveryStrength: number, patternType: string, openInterest: number, volume: number, rsi: number, supports: Array<number>, isMomentumBreakout: boolean, isInstitutionalEntry: boolean): Promise<void>;
    addRegion(regionId: bigint, name: string, coordinates: [number, number]): Promise<void>;
    addSummary(symbol: string, summary: string): Promise<void>;
    addValidationResult(symbol: string, modelName: string, result: string): Promise<void>;
    assignCallerUserRole(user: Principal, role: UserRole): Promise<void>;
    clearDailyAnalysis(symbol: string): Promise<void>;
    clearOldStats(): Promise<void>;
    clearValidationResults(symbol: string, modelName: string): Promise<void>;
    getAggregatedPredictions(symbol: string): Promise<Array<AssetOutcomes>>;
    getAlertConfig(regionId: bigint): Promise<AlertConfig>;
    getAllFlows(): Promise<Array<CapitalFlow>>;
    getAllModelPerformances(symbol: string): Promise<Array<ModelPerformance>>;
    getCachedPrices(): Promise<Array<PriceTicker>>;
    getCachedSymbols(): Promise<Array<string>>;
    getCallerUserProfile(): Promise<UserProfile | null>;
    getCallerUserRole(): Promise<UserRole>;
    getCapitalFlow(symbol: string): Promise<CapitalFlow>;
    getConfidenceMetrics(symbol: string): Promise<ConfidenceMetrics>;
    getConfluenceZone(symbol: string): Promise<ConfluenceZone>;
    getDayFlowRange(regionId: bigint, dayOfYear: bigint): Promise<DayFlowRange>;
    getInstitutionalAlerts(): Promise<Array<InstitutionalAlert>>;
    getInterpretation(symbol: string): Promise<{
        direction: string;
        summary: string;
        intensity: number;
    }>;
    getModelPerformance(symbol: string, modelName: string): Promise<ModelPerformance>;
    getOpenFuturesPositions(): Promise<Array<NormalizedFuturesPosition>>;
    getPerformanceSummary(symbol: string): Promise<PerformanceSummary>;
    getPredictionOutcomes(symbol: string): Promise<Array<PredictionOutcome>>;
    getPredictiveProjection(symbol: string): Promise<PredictiveProjection>;
    getRecoveryAsset(symbol: string): Promise<RecoveryAsset>;
    getRegion(regionId: bigint): Promise<Region>;
    getRegionConfigs(): Promise<Array<[bigint, RegionalFlowConfig]>>;
    getRegionCoordinates(): Promise<Array<[bigint, [number, number]]>>;
    getRegionalCorrelations(): Promise<Array<RegionalCorrelation>>;
    getRegionalCryptoAsset(regionId: bigint, symbol: string): Promise<RegionalCryptoAsset>;
    getRegionalFlowConfig(regionId: bigint): Promise<RegionalFlowConfig>;
    getRegionalMetric(regionId: bigint, metricType: string): Promise<RegionalMetric>;
    getUserProfile(user: Principal): Promise<UserProfile | null>;
    getValidationResults(symbol: string, modelName: string): Promise<Array<string>>;
    getValidationState(symbol: string): Promise<bigint>;
    hasBinanceCredentials(): Promise<boolean>;
    isCallerAdmin(): Promise<boolean>;
    isCriticalAlertDay(regionId: bigint, dayOfYear: bigint): Promise<boolean>;
    printVolumeChanges(): Promise<void>;
    removeBinanceCredentials(): Promise<void>;
    saveCallerUserProfile(profile: UserProfile): Promise<void>;
    testBinanceConnection(): Promise<string>;
    transform(input: TransformationInput): Promise<TransformationOutput>;
    updateDirection(symbol: string, direction: string, intensity: number): Promise<void>;
}
import type { BinanceFuturesMarket as _BinanceFuturesMarket, NormalizedFuturesPosition as _NormalizedFuturesPosition, TargetLevel as _TargetLevel, UserProfile as _UserProfile, UserRole as _UserRole } from "./declarations/backend.did.d.ts";
export class Backend implements backendInterface {
    constructor(private actor: ActorSubclass<_SERVICE>, private _uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, private _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, private processError?: (error: unknown) => never){}
    async _initializeAccessControlWithSecret(arg0: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor._initializeAccessControlWithSecret(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor._initializeAccessControlWithSecret(arg0);
            return result;
        }
    }
    async addCapitalFlow(arg0: string, arg1: CryptoAsset, arg2: CryptoAsset, arg3: number, arg4: number, arg5: number, arg6: number): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addCapitalFlow(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addCapitalFlow(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            return result;
        }
    }
    async addConfluenceZone(arg0: string, arg1: Array<string>, arg2: number): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addConfluenceZone(arg0, arg1, arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addConfluenceZone(arg0, arg1, arg2);
            return result;
        }
    }
    async addInstitutionalAlert(arg0: bigint, arg1: bigint, arg2: string, arg3: number, arg4: number): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addInstitutionalAlert(arg0, arg1, arg2, arg3, arg4);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addInstitutionalAlert(arg0, arg1, arg2, arg3, arg4);
            return result;
        }
    }
    async addModelPerformance(arg0: string, arg1: string, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addModelPerformance(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addModelPerformance(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            return result;
        }
    }
    async addOrUpdateBinanceCredentials(arg0: string, arg1: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addOrUpdateBinanceCredentials(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addOrUpdateBinanceCredentials(arg0, arg1);
            return result;
        }
    }
    async addPredictionOutcome(arg0: string, arg1: number, arg2: number, arg3: number, arg4: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addPredictionOutcome(arg0, arg1, arg2, arg3, arg4);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addPredictionOutcome(arg0, arg1, arg2, arg3, arg4);
            return result;
        }
    }
    async addPredictiveProjection(arg0: string, arg1: CryptoAsset, arg2: string, arg3: number, arg4: number, arg5: bigint, arg6: Array<TargetLevel> | null): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addPredictiveProjection(arg0, arg1, arg2, arg3, arg4, arg5, to_candid_opt_n1(this._uploadFile, this._downloadFile, arg6));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addPredictiveProjection(arg0, arg1, arg2, arg3, arg4, arg5, to_candid_opt_n1(this._uploadFile, this._downloadFile, arg6));
            return result;
        }
    }
    async addRecoveryAsset(arg0: string, arg1: number, arg2: string, arg3: number, arg4: number, arg5: number, arg6: Array<number>, arg7: boolean, arg8: boolean): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addRecoveryAsset(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addRecoveryAsset(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            return result;
        }
    }
    async addRegion(arg0: bigint, arg1: string, arg2: [number, number]): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addRegion(arg0, arg1, arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addRegion(arg0, arg1, arg2);
            return result;
        }
    }
    async addSummary(arg0: string, arg1: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addSummary(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addSummary(arg0, arg1);
            return result;
        }
    }
    async addValidationResult(arg0: string, arg1: string, arg2: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addValidationResult(arg0, arg1, arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addValidationResult(arg0, arg1, arg2);
            return result;
        }
    }
    async assignCallerUserRole(arg0: Principal, arg1: UserRole): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.assignCallerUserRole(arg0, to_candid_UserRole_n2(this._uploadFile, this._downloadFile, arg1));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.assignCallerUserRole(arg0, to_candid_UserRole_n2(this._uploadFile, this._downloadFile, arg1));
            return result;
        }
    }
    async clearDailyAnalysis(arg0: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.clearDailyAnalysis(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.clearDailyAnalysis(arg0);
            return result;
        }
    }
    async clearOldStats(): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.clearOldStats();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.clearOldStats();
            return result;
        }
    }
    async clearValidationResults(arg0: string, arg1: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.clearValidationResults(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.clearValidationResults(arg0, arg1);
            return result;
        }
    }
    async getAggregatedPredictions(arg0: string): Promise<Array<AssetOutcomes>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAggregatedPredictions(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAggregatedPredictions(arg0);
            return result;
        }
    }
    async getAlertConfig(arg0: bigint): Promise<AlertConfig> {
        if (this.processError) {
            try {
                const result = await this.actor.getAlertConfig(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAlertConfig(arg0);
            return result;
        }
    }
    async getAllFlows(): Promise<Array<CapitalFlow>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAllFlows();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAllFlows();
            return result;
        }
    }
    async getAllModelPerformances(arg0: string): Promise<Array<ModelPerformance>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAllModelPerformances(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAllModelPerformances(arg0);
            return result;
        }
    }
    async getCachedPrices(): Promise<Array<PriceTicker>> {
        if (this.processError) {
            try {
                const result = await this.actor.getCachedPrices();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCachedPrices();
            return result;
        }
    }
    async getCachedSymbols(): Promise<Array<string>> {
        if (this.processError) {
            try {
                const result = await this.actor.getCachedSymbols();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCachedSymbols();
            return result;
        }
    }
    async getCallerUserProfile(): Promise<UserProfile | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getCallerUserProfile();
                return from_candid_opt_n4(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCallerUserProfile();
            return from_candid_opt_n4(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCallerUserRole(): Promise<UserRole> {
        if (this.processError) {
            try {
                const result = await this.actor.getCallerUserRole();
                return from_candid_UserRole_n8(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCallerUserRole();
            return from_candid_UserRole_n8(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCapitalFlow(arg0: string): Promise<CapitalFlow> {
        if (this.processError) {
            try {
                const result = await this.actor.getCapitalFlow(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCapitalFlow(arg0);
            return result;
        }
    }
    async getConfidenceMetrics(arg0: string): Promise<ConfidenceMetrics> {
        if (this.processError) {
            try {
                const result = await this.actor.getConfidenceMetrics(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getConfidenceMetrics(arg0);
            return result;
        }
    }
    async getConfluenceZone(arg0: string): Promise<ConfluenceZone> {
        if (this.processError) {
            try {
                const result = await this.actor.getConfluenceZone(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getConfluenceZone(arg0);
            return result;
        }
    }
    async getDayFlowRange(arg0: bigint, arg1: bigint): Promise<DayFlowRange> {
        if (this.processError) {
            try {
                const result = await this.actor.getDayFlowRange(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getDayFlowRange(arg0, arg1);
            return result;
        }
    }
    async getInstitutionalAlerts(): Promise<Array<InstitutionalAlert>> {
        if (this.processError) {
            try {
                const result = await this.actor.getInstitutionalAlerts();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getInstitutionalAlerts();
            return result;
        }
    }
    async getInterpretation(arg0: string): Promise<{
        direction: string;
        summary: string;
        intensity: number;
    }> {
        if (this.processError) {
            try {
                const result = await this.actor.getInterpretation(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getInterpretation(arg0);
            return result;
        }
    }
    async getModelPerformance(arg0: string, arg1: string): Promise<ModelPerformance> {
        if (this.processError) {
            try {
                const result = await this.actor.getModelPerformance(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getModelPerformance(arg0, arg1);
            return result;
        }
    }
    async getOpenFuturesPositions(): Promise<Array<NormalizedFuturesPosition>> {
        if (this.processError) {
            try {
                const result = await this.actor.getOpenFuturesPositions();
                return from_candid_vec_n10(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getOpenFuturesPositions();
            return from_candid_vec_n10(this._uploadFile, this._downloadFile, result);
        }
    }
    async getPerformanceSummary(arg0: string): Promise<PerformanceSummary> {
        if (this.processError) {
            try {
                const result = await this.actor.getPerformanceSummary(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getPerformanceSummary(arg0);
            return result;
        }
    }
    async getPredictionOutcomes(arg0: string): Promise<Array<PredictionOutcome>> {
        if (this.processError) {
            try {
                const result = await this.actor.getPredictionOutcomes(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getPredictionOutcomes(arg0);
            return result;
        }
    }
    async getPredictiveProjection(arg0: string): Promise<PredictiveProjection> {
        if (this.processError) {
            try {
                const result = await this.actor.getPredictiveProjection(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getPredictiveProjection(arg0);
            return result;
        }
    }
    async getRecoveryAsset(arg0: string): Promise<RecoveryAsset> {
        if (this.processError) {
            try {
                const result = await this.actor.getRecoveryAsset(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getRecoveryAsset(arg0);
            return result;
        }
    }
    async getRegion(arg0: bigint): Promise<Region> {
        if (this.processError) {
            try {
                const result = await this.actor.getRegion(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getRegion(arg0);
            return result;
        }
    }
    async getRegionConfigs(): Promise<Array<[bigint, RegionalFlowConfig]>> {
        if (this.processError) {
            try {
                const result = await this.actor.getRegionConfigs();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getRegionConfigs();
            return result;
        }
    }
    async getRegionCoordinates(): Promise<Array<[bigint, [number, number]]>> {
        if (this.processError) {
            try {
                const result = await this.actor.getRegionCoordinates();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getRegionCoordinates();
            return result;
        }
    }
    async getRegionalCorrelations(): Promise<Array<RegionalCorrelation>> {
        if (this.processError) {
            try {
                const result = await this.actor.getRegionalCorrelations();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getRegionalCorrelations();
            return result;
        }
    }
    async getRegionalCryptoAsset(arg0: bigint, arg1: string): Promise<RegionalCryptoAsset> {
        if (this.processError) {
            try {
                const result = await this.actor.getRegionalCryptoAsset(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getRegionalCryptoAsset(arg0, arg1);
            return result;
        }
    }
    async getRegionalFlowConfig(arg0: bigint): Promise<RegionalFlowConfig> {
        if (this.processError) {
            try {
                const result = await this.actor.getRegionalFlowConfig(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getRegionalFlowConfig(arg0);
            return result;
        }
    }
    async getRegionalMetric(arg0: bigint, arg1: string): Promise<RegionalMetric> {
        if (this.processError) {
            try {
                const result = await this.actor.getRegionalMetric(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getRegionalMetric(arg0, arg1);
            return result;
        }
    }
    async getUserProfile(arg0: Principal): Promise<UserProfile | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getUserProfile(arg0);
                return from_candid_opt_n4(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getUserProfile(arg0);
            return from_candid_opt_n4(this._uploadFile, this._downloadFile, result);
        }
    }
    async getValidationResults(arg0: string, arg1: string): Promise<Array<string>> {
        if (this.processError) {
            try {
                const result = await this.actor.getValidationResults(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getValidationResults(arg0, arg1);
            return result;
        }
    }
    async getValidationState(arg0: string): Promise<bigint> {
        if (this.processError) {
            try {
                const result = await this.actor.getValidationState(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getValidationState(arg0);
            return result;
        }
    }
    async hasBinanceCredentials(): Promise<boolean> {
        if (this.processError) {
            try {
                const result = await this.actor.hasBinanceCredentials();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.hasBinanceCredentials();
            return result;
        }
    }
    async isCallerAdmin(): Promise<boolean> {
        if (this.processError) {
            try {
                const result = await this.actor.isCallerAdmin();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.isCallerAdmin();
            return result;
        }
    }
    async isCriticalAlertDay(arg0: bigint, arg1: bigint): Promise<boolean> {
        if (this.processError) {
            try {
                const result = await this.actor.isCriticalAlertDay(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.isCriticalAlertDay(arg0, arg1);
            return result;
        }
    }
    async printVolumeChanges(): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.printVolumeChanges();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.printVolumeChanges();
            return result;
        }
    }
    async removeBinanceCredentials(): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.removeBinanceCredentials();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.removeBinanceCredentials();
            return result;
        }
    }
    async saveCallerUserProfile(arg0: UserProfile): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.saveCallerUserProfile(to_candid_UserProfile_n15(this._uploadFile, this._downloadFile, arg0));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.saveCallerUserProfile(to_candid_UserProfile_n15(this._uploadFile, this._downloadFile, arg0));
            return result;
        }
    }
    async testBinanceConnection(): Promise<string> {
        if (this.processError) {
            try {
                const result = await this.actor.testBinanceConnection();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.testBinanceConnection();
            return result;
        }
    }
    async transform(arg0: TransformationInput): Promise<TransformationOutput> {
        if (this.processError) {
            try {
                const result = await this.actor.transform(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.transform(arg0);
            return result;
        }
    }
    async updateDirection(arg0: string, arg1: string, arg2: number): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateDirection(arg0, arg1, arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateDirection(arg0, arg1, arg2);
            return result;
        }
    }
}
function from_candid_BinanceFuturesMarket_n13(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _BinanceFuturesMarket): BinanceFuturesMarket {
    return from_candid_variant_n14(_uploadFile, _downloadFile, value);
}
function from_candid_NormalizedFuturesPosition_n11(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _NormalizedFuturesPosition): NormalizedFuturesPosition {
    return from_candid_record_n12(_uploadFile, _downloadFile, value);
}
function from_candid_UserProfile_n5(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _UserProfile): UserProfile {
    return from_candid_record_n6(_uploadFile, _downloadFile, value);
}
function from_candid_UserRole_n8(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _UserRole): UserRole {
    return from_candid_variant_n9(_uploadFile, _downloadFile, value);
}
function from_candid_opt_n4(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_UserProfile]): UserProfile | null {
    return value.length === 0 ? null : from_candid_UserProfile_n5(_uploadFile, _downloadFile, value[0]);
}
function from_candid_opt_n7(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [string]): string | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_record_n12(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    pnl: number;
    markPrice: number;
    leverage: number;
    positionSide: string;
    liquidationPrice: number;
    entryPrice: number;
    market: _BinanceFuturesMarket;
    symbol: string;
    positionAmt: number;
}): {
    pnl: number;
    markPrice: number;
    leverage: number;
    positionSide: string;
    liquidationPrice: number;
    entryPrice: number;
    market: BinanceFuturesMarket;
    symbol: string;
    positionAmt: number;
} {
    return {
        pnl: value.pnl,
        markPrice: value.markPrice,
        leverage: value.leverage,
        positionSide: value.positionSide,
        liquidationPrice: value.liquidationPrice,
        entryPrice: value.entryPrice,
        market: from_candid_BinanceFuturesMarket_n13(_uploadFile, _downloadFile, value.market),
        symbol: value.symbol,
        positionAmt: value.positionAmt
    };
}
function from_candid_record_n6(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    name: string;
    email: [] | [string];
    preferences: [] | [string];
}): {
    name: string;
    email?: string;
    preferences?: string;
} {
    return {
        name: value.name,
        email: record_opt_to_undefined(from_candid_opt_n7(_uploadFile, _downloadFile, value.email)),
        preferences: record_opt_to_undefined(from_candid_opt_n7(_uploadFile, _downloadFile, value.preferences))
    };
}
function from_candid_variant_n14(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    usdt_m: null;
} | {
    coin_m: null;
}): BinanceFuturesMarket {
    return "usdt_m" in value ? BinanceFuturesMarket.usdt_m : "coin_m" in value ? BinanceFuturesMarket.coin_m : value;
}
function from_candid_variant_n9(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    admin: null;
} | {
    user: null;
} | {
    guest: null;
}): UserRole {
    return "admin" in value ? UserRole.admin : "user" in value ? UserRole.user : "guest" in value ? UserRole.guest : value;
}
function from_candid_vec_n10(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_NormalizedFuturesPosition>): Array<NormalizedFuturesPosition> {
    return value.map((x)=>from_candid_NormalizedFuturesPosition_n11(_uploadFile, _downloadFile, x));
}
function to_candid_UserProfile_n15(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: UserProfile): _UserProfile {
    return to_candid_record_n16(_uploadFile, _downloadFile, value);
}
function to_candid_UserRole_n2(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: UserRole): _UserRole {
    return to_candid_variant_n3(_uploadFile, _downloadFile, value);
}
function to_candid_opt_n1(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<TargetLevel> | null): [] | [Array<_TargetLevel>] {
    return value === null ? candid_none() : candid_some(value);
}
function to_candid_record_n16(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    name: string;
    email?: string;
    preferences?: string;
}): {
    name: string;
    email: [] | [string];
    preferences: [] | [string];
} {
    return {
        name: value.name,
        email: value.email ? candid_some(value.email) : candid_none(),
        preferences: value.preferences ? candid_some(value.preferences) : candid_none()
    };
}
function to_candid_variant_n3(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: UserRole): {
    admin: null;
} | {
    user: null;
} | {
    guest: null;
} {
    return value == UserRole.admin ? {
        admin: null
    } : value == UserRole.user ? {
        user: null
    } : value == UserRole.guest ? {
        guest: null
    } : value;
}
export interface CreateActorOptions {
    agent?: Agent;
    agentOptions?: HttpAgentOptions;
    actorOptions?: ActorConfig;
    processError?: (error: unknown) => never;
}
export function createActor(canisterId: string, _uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, options: CreateActorOptions = {}): Backend {
    const agent = options.agent || HttpAgent.createSync({
        ...options.agentOptions
    });
    if (options.agent && options.agentOptions) {
        console.warn("Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent.");
    }
    const actor = Actor.createActor<_SERVICE>(idlFactory, {
        agent,
        canisterId: canisterId,
        ...options.actorOptions
    });
    return new Backend(actor, _uploadFile, _downloadFile, options.processError);
}
